\documentclass {article}
\usepackage[margin=2.5cm]{geometry}
\usepackage {polski}
\usepackage {float}
\usepackage {graphicx}
\usepackage{indentfirst}
\usepackage[utf8]{inputenc}

\author {Michał Cybulski, Piotr Grzegorski}
\title {PORR -- Projekt\\Etap 1.}
\date {30 listopada 2015r.}
\begin {document}

\maketitle

\section {Zadanie}

Wyznaczanie najkrótszej ścieżki w grafie metodą aukcyjną, porównanie z algorytmem Dijkstry.

Zdecydowano o realizacji zadania przy pomocy technologii OpenMP.

\section{Implementacja}

Program został napisany w języku C przy wykorzystaniu interfejsu programowania aplikacji \emph{OpenMP} (ang. ..\emph{Open Multi-Processing}''), który wspiera tworzenie aplikacji na systemy wieloprocesorowe z pamięcią współdzieloną.

Na cały program składają się:
\begin{itemize}
    \item Generator grafów
    \item Algorytm Dijkstry
    \item Algorytm Aukcyjny
\end{itemize}

Implementacje generatora grafów oraz algorytmu Dijkstry opierają się na kodzie znalezionym w internecie, natomiast algorytm aukcyjny został zaimplementowany na potrzeby projektu od zera. 

Współbieżna implementacja algorytmu aukcyjnego wyznaczenia najkrótszej ścieżki w grafie oparta jest o artykuł \cite{Bertsekas1991}. W standardowej wersji algorytm ten ma za zadanie znaleźć tylko jedną, najkrótszą ścieżkę pomiędzy dwoma wybranymi wierzchołkami grafu przestrzegając prostych zasad podczas poruszania się po nim. Taką wersję algorytmu trudno jest jednak zrównoleglić. Algorytm aukcyjny bardzo dobrze zrównolegla się, gdy zamiast skupienia się na szukaniu ścieżki między parą wierzchołków, rozpatrujemy przypadek szukania najkrótszych ścieżek prowadzących do jednego wierzchołka-celu wychodząc z wielu innych wierzchołków.

\subsection{Argumenty wywołania}

Aplikacja wymaga trzech liczbowych parametrów:

\begin{enumerate}
 \item liczba wierzchołków grafu
 \item liczba krawędzi grafu
 \item maksymalna waga krawędzi
\end{enumerate}

Dodatkowy, opcjonalny parametr to poziom logowania. Na potrzeby testów można podać wartość 10, która zaskutkuje wypisaniem tylko jednej linii podsumowania zawierającej same liczby.

\subsection{Przebieg działania programu}

Generuj --> wywołaj Dijkstrę --> jeśli graf niespojny odrzucamy wynik, jesli spojny wywołaj aukcyjny --> end

\subsection{Zrównoleglenie algorytmu Dijkstry}

Każdy wątek sprawdza odległość dla podległych sobie wierzchołków.

\subsection{Sekwencyjny algorytm aukcyjny}

Sekwencyjna wersja algorytmu opisana w książce \cite{Bertsekas1998} polega na iteracyjnym budowaniu listy wierzchołków, które składają się na szukaną najkrótszą ścieżkę. Poza listą wierzchołków utrzymywany jest też wektor cen/kosztów wierzchołków.

W każdej iteracji, w zależności od wyniku porównania kosztu ostatniego wierzchołka na liście z minimalną sumą kosztu wierzchołka sąsiedniego oraz wagi krawędzi do niego prowadzącej, do listy albo dodawany jest kolejny wierzchołek-sąsiad, albo z listy usuwany jest ostatni wierzchołek i uaktualniany jset wektor cen/kosztów. Wykonując kolejne iteracje algorytm zbliża się do szukanego wierzchołka i przerywany jest w momencie, gdy go znajdzie. W przypadku gdy nie istnieje żadna ścieżka prowadząca z wierzchołka początkowego do wierzchołka końcowego, algorytm będzie zapętlony w nieskończoność, a koszty wierzchołków będą dążyły do nieskończoności.

\subsection{Zrównoleglenie algorytmu aukcyjnego}

Gdy rozpatrzymy problem szukania ścieżek wychodzących z wielu wierzchołków, a kończących się w jednym wybranym wierzchołku, algorytm aukcyjny bardzo dobrze się zrównolega. Jedno z rozwiązań problemu zasugerowane w artykule \cite{Bertsekas1991} przewiduje wspólną synchroniczną pracę wielu wątków/procesów nad jednym współdzielonym wektorem kosztów.

Każdy wątek odpowiada za szukanie ścieżki rozpoczynającej się w wybranym wierzchołku porównując odpowiadający sobie koszt z sumami kosztów i wag krawędzi prowadzących do wierzchołków sąsiednich, a po zakończeniu iteracji, wyniki poszczególnych wątków są przetwarzane w celu budowania wspólnego wektora kosztów. Autor artykułu zauważa, że jeżeli jakiś wierzchołek jest w danej iteracji ostatnim wierzchołkiem kilku list wierzchołków pochodzących z różnych ,,punktów startowych'', to wynik iteracji w każdym z tych wątków będzie taki sam - czyli takie samo wydłużenie, bądź skrócenie listy wierzchołków. Nie wystąpią więc problemy z wyścigami pomiędzy wątkami.

Jedyna sytuacja, w której może powstać konflikt, to sytuacja gdy pewien wierzchołek jest ostatnim wierzchołkiem listy jednego wątku, a dopiero ma stać się ostatnim wierzchołkiem innego. W przypadku, gdy okaże się, że wynikiem iteracji pierwszego wątku ma być skrócenie listy wierzchołków i zwiększenie kosztu rozpatrywanego wierzchołka, to operacja wydłużenia listy drugiego wątku powinna zostać wstrzymana do czasu kolejnej iteracji.

\section{Testy}

Testy obu algorytmów wykonywano dla tych samych grafów -- zarówno generowanych losowo, jak i ze stałym ziarnem losowości. Wywołania sekwencyjne pozwoliło zrealizować ustawienie zmiennej środowiskowej \verb|OMP_NUM_THREADS| na wartość 1. Testy były wykonywane w pętli po 1000 uruchomień (wyjątek stanowią testy dla grafów o 10000 wierzchołków -- te uruchamiane były po 500 razy).

Wynik testu stanowiła mediana czasu wykonania -- pozwoliło to ograniczyć wpływ sytuacji wyjątkowych, np. dodatkowego chwilowego obciążenia systemu, na uzyskane rezultaty.

W toku testowania wykazano, że wpływ na wydajność programu miały niejawne synchronizacje na funkcji logującej, zdecydowano więc o wykomentowaniu jej wywołań na potrzeby testowania. Poniższe wyniki uzyskano po poprawce.

\subsection{Wyniki czasowe}



\subsection{Analiza wyników}

Wbrew przewidywaniom wydajność spadła po zrównolegleniu obliczeń. Dla dużych grafów różnica w czasie wykonania była nieduża, dla małych -- nawet dziesięciokrotna. Profilowanie przy pomocy programu gprof ujawniło duży narzut spowodowany oczekiwaniem na barierach OpenMP -- mechanizm ten jest stosowany w obu algorytmach.

\section{Wnioski}

Gorsze wyniki wydajnościowe uzyskiwane po zrównolegleniu wykonania obliczeń mogą oczywiście świadczyć o defektach kodu algorytmu, jednak 


KURWA NO NIE, to algorytmy są sekwencyjne i chuj, tej wersji bede sie trzymał

\begin{thebibliography}{9}

    \bibitem{Bertsekas1998}
        Dimitri P. Bertsekas
        \emph{Network Optimization: Continuous and Discrete Models}
        Athena Scientific
        1998.

    \bibitem{Bertsekas1991}
        Dimitri P. Bertsekas,
        \emph{An Auction Algorithm For Shortest Paths}.
        SIAM Journal on Optimization,
        Vol. 1, No. 4, pp. 425-447
        November 1991.
      
\end{thebibliography}

\end {document}
